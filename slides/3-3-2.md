Voici la présentation de 6 slides que j'ai préparée pour vous, en respectant vos consignes :

---

## Architecture de Kubernetes : Master et Workers

Kubernetes est une plateforme d’orchestration pour gérer des applications conteneurisées à grande échelle.

Son architecture repose sur une séparation claire entre :

*   **Master (Plan de contrôle)** : Gère l’état du cluster, orchestre les tâches et prend les décisions.
*   **Workers (Nœuds)** : Exécutent les applications conteneurisées.

Cette séparation assure une haute disponibilité et une capacité d’évolution horizontale.

---

## Le Master : Le Cerveau du Cluster

Le Master contrôle l’ensemble des opérations dans le cluster. Il est composé de :

*   **API Server** :
    *   Interface principale de Kubernetes.
    *   Toutes les commandes (`kubectl` ou API) passent par elle.

*   **Scheduler** :
    *   Assigne les pods aux nœuds selon les contraintes (ressources, affinités).
    *   Garantit équilibre et optimisation des ressources.

---

## Composants du Master

*   **Controller Manager** :
    *   Exécute les *controllers* qui régulent l’état du cluster.
    *   Exemple : S’assurer que le nombre de pods désirés est créé et maintenu.

*   **etcd** :
    *   Base de données clé-valeur distribuée et fiable.
    *   Stocke l’état et la configuration complète du cluster.

---

## Les Workers : Les Exécutants des Conteneurs

Les Workers sont responsables de l’exécution effective des conteneurs. Chaque nœud Worker intègre :

*   **Kubelet** :
    *   Agent qui tourne sur chaque nœud.
    *   Surveille les pods affectés et communique avec le Master.
    *   Reçoit les directives du Master pour la gestion des pods.

*   **Kube-proxy** :
    *   Gère la mise en réseau pour les pods.
    *   Responsable du routage des paquets et de l'implémentation du *load balancing* interne.

*   **Conteneur runtime** :
    *   La couche qui exécute réellement les conteneurs (ex : Docker, containerd, CRI-O).

---

## Interaction Master-Worker et Schéma Résumé

**Exemple simple d'interaction :**

1.  **Administrateur** lance `kubectl create deployment`.
2.  **API Server** (Master) traite la requête.
3.  **Scheduler** (Master) attribue les pods aux nœuds libres.
4.  **Kubelet** (Worker ciblé) récupère la définition du pod et lance les conteneurs via le runtime.
5.  **Kube-proxy** (Worker) configure le réseau pour la communication avec le pod.

```
     +---------------------+
     |       Master        |
     | +-----------------+ |
     | | API Server      | |
     | | Scheduler       | |
     | | Controller Mgr  | |
     | | etcd            | |
     | +-----------------+ |
     +----------|----------+
                |
   +------------+------------+
   |                         |
+----+                   +----+
|Node|                   |Node|
|Kube|                   |Kube|
|let |                   |let |
|Proxy|                   |Proxy|
|CRI  |                   |CRI  |
+----+                   +----+
```

---

## Synthèse & Ressources

**Ce qu'il faut retenir :**

L’architecture Master-Worker de Kubernetes sépare clairement les responsabilités entre gestion et exécution. Cela assure une **scalabilité** et une **robustesse** accrues de la plateforme. La maîtrise de ces composants fondamentaux est essentielle pour comprendre l’orchestration de conteneurs et les mécanismes de déploiement automatisés.

**Sources utilisées :**

*   Kubernetes Official Documentation, *Cluster Architecture*: https://kubernetes.io/docs/concepts/overview/components/
*   CNCF, *Introduction to Kubernetes Components* : https://www.cncf.io/blog/2019/02/22/introduction-to-kubernetes-architecture/
*   DigitalOcean, *Understanding Kubernetes Architecture* : https://www.digitalocean.com/community/tutorials/understanding-kubernetes-architecture-components